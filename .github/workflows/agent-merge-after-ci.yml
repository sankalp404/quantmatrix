name: Auto-squash merge agent PRs after CI (when approved)

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  pull_request_review:
    types: [submitted]

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  merge_if_approved:
    name: Merge (squash) if approved
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Merge approved agent PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"

          if [[ "$EVENT" == "workflow_run" ]]; then
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            CI_SHA="${{ github.event.workflow_run.head_sha }}"
          elif [[ "$EVENT" == "pull_request_review" ]]; then
            BRANCH="${{ github.event.pull_request.head.ref }}"
            CI_SHA=""  # not available/relevant for review-triggered runs
          else
            echo "Unsupported event: $EVENT"
            exit 0
          fi

          # Only handle agent branches
          if [[ "$BRANCH" != agent/* ]]; then
            echo "Skip: not an agent branch ($BRANCH)"
            exit 0
          fi

          # Find the open PR for this head branch (if any)
          if [[ "$EVENT" == "pull_request_review" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="$(gh pr list --repo "$REPO" --head "$BRANCH" --state open --json number --jq '.[0].number')"
          fi
          if [[ -z "${PR_NUMBER:-}" || "${PR_NUMBER}" == "null" ]]; then
            echo "No open PR found for $BRANCH"
            exit 0
          fi

          PR_JSON="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json id,headRefOid,mergeStateStatus,reviews,isDraft)"
          PR_ID="$(echo "$PR_JSON" | jq -r '.id')"
          HEAD_OID="$(echo "$PR_JSON" | jq -r '.headRefOid')"
          MERGE_STATE="$(echo "$PR_JSON" | jq -r '.mergeStateStatus')"
          IS_DRAFT="$(echo "$PR_JSON" | jq -r '.isDraft')"

          # For workflow_run, ensure the run corresponds to the current PR head SHA.
          if [[ "$EVENT" == "workflow_run" ]]; then
            if [[ "$HEAD_OID" != "$CI_SHA" ]]; then
              echo "Skip: CI SHA ($CI_SHA) != PR head ($HEAD_OID). New commits likely pushed."
              exit 0
            fi
          fi

          # Never auto-merge draft PRs (must be marked Ready for review first).
          if [[ "$IS_DRAFT" == "true" ]]; then
            echo "Skip: PR #$PR_NUMBER is draft"
            exit 0
          fi

          APPROVED_BY_OWNER="$(echo "$PR_JSON" | jq -r '[.reviews[] | select(.state=="APPROVED") | .author.login] | any(. == "sankalp404")')"
          if [[ "$APPROVED_BY_OWNER" != "true" ]]; then
            echo "PR #$PR_NUMBER not approved by sankalp404"
            exit 0
          fi

          # If branch is behind main (ruleset requires up-to-date), update it from main and rerun CI.
          if [[ "$MERGE_STATE" == "BEHIND" ]]; then
            echo "PR #$PR_NUMBER is BEHIND main; updating branch then rerunning CI."

            gh api graphql -f query='
              mutation($prId:ID!, $expected:GitObjectID!) {
                updatePullRequestBranch(input:{pullRequestId:$prId, expectedHeadOid:$expected}) {
                  pullRequest { number }
                }
              }' -f prId="$PR_ID" -f expected="$HEAD_OID" >/dev/null

            # CI may not fire automatically for bot-created PR events; dispatch explicitly.
            gh workflow run "CI" --repo "$REPO" --ref "$BRANCH"
            exit 0
          fi

          # GitHub's mergeStateStatus can lag (often UNSTABLE) even when required checks are actually green.
          # So we poll the PR's check rollup for the required checks, then attempt merge with retries.
          #
          # NOTE: We intentionally ignore this workflow's own check ("Merge (squash) if approved")
          # to avoid self-deadlock.

          required_checks=(
            "Backend (pytest in docker)"
            "Frontend (lint/typecheck/test)"
          )
          max_attempts=90     # ~15 minutes at 10s
          sleep_seconds=10

          for i in $(seq 1 "$max_attempts"); do
            PR_JSON="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json mergeStateStatus,isDraft,reviews,statusCheckRollup)"
            MERGE_STATE="$(echo "$PR_JSON" | jq -r '.mergeStateStatus')"
            IS_DRAFT="$(echo "$PR_JSON" | jq -r '.isDraft')"

            if [[ "$IS_DRAFT" == "true" ]]; then
              echo "Skip: PR #$PR_NUMBER is draft"
              exit 0
            fi

            APPROVED_BY_OWNER="$(echo "$PR_JSON" | jq -r '[.reviews[] | select(.state=="APPROVED") | .author.login] | any(. == "sankalp404")')"
            if [[ "$APPROVED_BY_OWNER" != "true" ]]; then
              echo "Skip: PR #$PR_NUMBER not approved by sankalp404"
              exit 0
            fi

            if [[ "$MERGE_STATE" == "BEHIND" ]]; then
              echo "PR #$PR_NUMBER is BEHIND main; updating branch then rerunning CI."
              PR_ID="$(echo "$PR_JSON" | jq -r '.id' 2>/dev/null || true)"
              HEAD_OID="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json headRefOid --jq '.headRefOid')"
              if [[ -z "${PR_ID:-}" || "${PR_ID}" == "null" ]]; then
                PR_ID="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json id --jq '.id')"
              fi
              gh api graphql -f query='
                mutation($prId:ID!, $expected:GitObjectID!) {
                  updatePullRequestBranch(input:{pullRequestId:$prId, expectedHeadOid:$expected}) {
                    pullRequest { number }
                  }
                }' -f prId="$PR_ID" -f expected="$HEAD_OID" >/dev/null
              gh workflow run "CI" --repo "$REPO" --ref "$BRANCH"
              exit 0
            fi

            # Evaluate required checks.
            missing=0
            pending=0
            failing=0

            for name in "${required_checks[@]}"; do
              item="$(echo "$PR_JSON" | jq -c --arg n "$name" '.statusCheckRollup[]? | select(.name == $n) | {status, conclusion} ' | tail -n 1)"
              if [[ -z "${item:-}" ]]; then
                missing=$((missing+1))
                continue
              fi

              status="$(echo "$item" | jq -r '.status')"
              conclusion="$(echo "$item" | jq -r '.conclusion // ""')"
              if [[ "$status" != "COMPLETED" ]]; then
                pending=$((pending+1))
                continue
              fi
              if [[ "$conclusion" != "SUCCESS" ]]; then
                failing=$((failing+1))
              fi
            done

            if [[ "$failing" -gt 0 ]]; then
              echo "Skip: required checks failing (attempt $i/$max_attempts)."
              exit 0
            fi

            if [[ "$missing" -gt 0 || "$pending" -gt 0 ]]; then
              echo "Waiting for required checks... (missing=$missing pending=$pending mergeStateStatus=$MERGE_STATE) attempt $i/$max_attempts"
              sleep "$sleep_seconds"
              continue
            fi

            # Required checks are green; try merging. If GitHub still says not mergeable,
            # retry for a bit (mergeability can lag check completion).
            echo "Required checks are green; attempting merge (mergeStateStatus=$MERGE_STATE) attempt $i/$max_attempts"
            set +e
            gh pr merge "$PR_NUMBER" --repo "$REPO" --squash --delete-branch
            rc=$?
            set -e
            if [[ "$rc" -eq 0 ]]; then
              exit 0
            fi
            echo "Merge attempt failed (exit=$rc); waiting and retrying..."
            sleep "$sleep_seconds"
          done

          echo "Timed out waiting for checks/mergeability; leaving PR open."
          exit 0


