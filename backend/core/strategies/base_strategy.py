from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import pandas as pd

@dataclass
class SignalResult:
    """Represents a trading signal generated by a strategy."""
    symbol: str
    signal_type: str  # ENTRY, EXIT, SCALE_OUT
    strength: float  # 0.0 to 1.0
    price: float
    timestamp: datetime
    strategy_name: str
    
    # Risk management
    stop_loss: Optional[float] = None
    target_price: Optional[float] = None
    position_size_pct: Optional[float] = None
    risk_reward_ratio: Optional[float] = None
    
    # Strategy specific data
    metadata: Dict = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

@dataclass
class StrategyAnalysis:
    """Comprehensive analysis result for a symbol."""
    symbol: str
    current_price: float
    timestamp: datetime
    strategy_name: str
    
    # Analysis results
    signals: List[SignalResult]
    technical_data: Dict
    risk_metrics: Dict
    
    # Overall assessment
    overall_score: float  # 0.0 to 1.0
    recommendation: str  # BUY, SELL, HOLD, SCALE_OUT
    confidence: float  # 0.0 to 1.0

class BaseStrategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, name: str):
        self.name = name
        self.enabled = True
        self.parameters = {}
    
    @abstractmethod
    async def analyze(self, symbol: str, market_data: Dict) -> StrategyAnalysis:
        """
        Analyze a symbol and return comprehensive analysis.
        
        Args:
            symbol: Stock symbol to analyze
            market_data: Market data including price and technical indicators
            
        Returns:
            StrategyAnalysis object with signals and analysis
        """
        pass
    
    @abstractmethod
    def generate_signals(self, symbol: str, technical_data: Dict) -> List[SignalResult]:
        """
        Generate trading signals based on technical analysis.
        
        Args:
            symbol: Stock symbol
            technical_data: Technical indicators data
            
        Returns:
            List of SignalResult objects
        """
        pass
    
    @abstractmethod
    def calculate_position_size(
        self, 
        symbol: str, 
        price: float, 
        portfolio_value: float, 
        risk_per_trade: float = 0.02
    ) -> float:
        """
        Calculate position size based on risk management rules.
        
        Args:
            symbol: Stock symbol
            price: Current price
            portfolio_value: Total portfolio value
            risk_per_trade: Risk percentage per trade (default 2%)
            
        Returns:
            Number of shares to trade
        """
        pass
    
    @abstractmethod
    def calculate_stop_loss(self, symbol: str, entry_price: float, technical_data: Dict) -> float:
        """
        Calculate stop loss price.
        
        Args:
            symbol: Stock symbol
            entry_price: Entry price
            technical_data: Technical indicators
            
        Returns:
            Stop loss price
        """
        pass
    
    @abstractmethod
    def calculate_targets(self, symbol: str, entry_price: float, technical_data: Dict) -> List[float]:
        """
        Calculate target prices.
        
        Args:
            symbol: Stock symbol
            entry_price: Entry price
            technical_data: Technical indicators
            
        Returns:
            List of target prices
        """
        pass
    
    def validate_signal(self, signal: SignalResult, market_conditions: Dict) -> bool:
        """
        Validate if a signal is still valid given current market conditions.
        
        Args:
            signal: Signal to validate
            market_conditions: Current market conditions
            
        Returns:
            True if signal is valid, False otherwise
        """
        # Base validation - can be overridden by specific strategies
        if signal.strength < 0.3:  # Minimum signal strength
            return False
        
        # Check if signal is too old (more than 1 hour for intraday)
        time_diff = datetime.now() - signal.timestamp
        if time_diff.total_seconds() > 3600:  # 1 hour
            return False
        
        return True
    
    def calculate_risk_reward_ratio(
        self, 
        entry_price: float, 
        stop_loss: float, 
        target_price: float
    ) -> float:
        """Calculate risk/reward ratio."""
        if stop_loss >= entry_price:
            return 0.0
        
        risk = entry_price - stop_loss
        reward = target_price - entry_price
        
        if risk <= 0:
            return 0.0
        
        return reward / risk
    
    def set_parameter(self, key: str, value):
        """Set strategy parameter."""
        self.parameters[key] = value
    
    def get_parameter(self, key: str, default=None):
        """Get strategy parameter."""
        return self.parameters.get(key, default)
    
    def enable(self):
        """Enable the strategy."""
        self.enabled = True
    
    def disable(self):
        """Disable the strategy."""
        self.enabled = False
    
    def is_enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self.enabled
    
    def get_name(self) -> str:
        """Get strategy name."""
        return self.name 