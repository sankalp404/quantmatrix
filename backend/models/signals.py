from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey, Enum, Index, JSON, UniqueConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum
from backend.models import Base

class SignalType(enum.Enum):
    ENTRY = "entry"
    EXIT = "exit"
    SCALE_OUT = "scale_out"
    STOP_LOSS = "stop_loss"
    ALERT = "alert"

class SignalStatus(enum.Enum):
    PENDING = "pending"
    ACTIVE = "active"
    TRIGGERED = "triggered"
    EXPIRED = "expired"
    CANCELLED = "cancelled"

class StrategyType(enum.Enum):
    ATR_MATRIX = "atr_matrix"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    CUSTOM = "custom"

class NotificationType(enum.Enum):
    SIGNAL = "signal"
    ALERT = "alert"
    PORTFOLIO_UPDATE = "portfolio_update"
    STRATEGY_RESULT = "strategy_result"
    REBALANCE = "rebalance"
    MARGIN_CALL = "margin_call"

# =============================================================================
# SIGNALS
# =============================================================================

class Signal(Base):
    """Trading signals generated by strategies."""
    __tablename__ = "signals"
    
    id = Column(Integer, primary_key=True)
    strategy_id = Column(Integer, ForeignKey("strategies.id"), nullable=False)
    strategy_run_id = Column(Integer, ForeignKey("strategy_runs.id"), nullable=False)
    symbol = Column(String(20), nullable=False)
    
    # Signal details
    signal_type = Column(Enum(SignalType), nullable=False)
    signal_strength = Column(Float)  # 0.0 to 1.0 confidence score
    generated_at = Column(DateTime, nullable=False)
    expires_at = Column(DateTime)
    
    # Price levels
    entry_price = Column(Float, nullable=False)
    current_price = Column(Float, nullable=False)
    stop_loss = Column(Float)
    take_profit = Column(Float)
    targets = Column(JSON)  # Multiple target levels
    
    # Strategy-specific metrics
    atr_distance = Column(Float)
    rsi = Column(Float)
    ma_alignment = Column(Boolean)
    risk_reward_ratio = Column(Float)
    time_horizon = Column(String(50))  # "1-3 days", "1-2 weeks", etc.
    
    # Company information
    company_name = Column(String(200))
    company_synopsis = Column(Text)
    sector = Column(String(50))
    market_cap = Column(Float)
    market_cap_category = Column(String(20))
    
    # Performance tracking
    status = Column(Enum(SignalStatus), default=SignalStatus.PENDING)
    max_price_reached = Column(Float)
    min_price_reached = Column(Float)
    actual_return = Column(Float)
    days_active = Column(Integer, default=0)
    
    # Execution tracking
    is_executed = Column(Boolean, default=False)
    execution_price = Column(Float)
    execution_date = Column(DateTime)
    quantity_executed = Column(Float)
    
    # Analysis
    signal_accuracy = Column(Float)  # Did it reach targets?
    lessons_learned = Column(Text)
    
    # Audit & Lifecycle Tracking
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Processing Audit Trail
    started_audit = Column(DateTime)                    # When signal processing started
    completed_audit = Column(DateTime)                  # When signal processing completed
    last_evaluated_at = Column(DateTime)                # Last performance evaluation
    
    # User/System Tracking
    created_by_user_id = Column(Integer, ForeignKey("users.id"))  # Manual signals
    modified_by_user_id = Column(Integer, ForeignKey("users.id")) # Who last modified
    processing_node = Column(String(50))                # Which server processed this
    
    # Audit Context
    audit_metadata = Column(JSON)                       # Processing context, errors, etc.
    version = Column(Integer, default=1)                # Signal version for updates
    
    # Relationships
    strategy = relationship("Strategy", back_populates="signals")
    strategy_run = relationship("StrategyRun", back_populates="signals")
    
    # Indexes
    __table_args__ = (
        Index('idx_signals_symbol_date', 'symbol', 'generated_at'),  # Made unique
        Index('idx_strategy_symbol', 'strategy_id', 'symbol'),
        Index('idx_signal_type_status', 'signal_type', 'status'),
        Index('idx_generated_at', 'generated_at'),
        UniqueConstraint('strategy_id', 'symbol', 'generated_at', name='uq_strategy_symbol_signal'),
    )

# =============================================================================
# NOTIFICATIONS
# =============================================================================
# Note: Notification model is defined in notifications.py
# Import from backend.models.notifications if needed

class MarketDataCache(Base):
    """Cache for market data to reduce API calls."""
    __tablename__ = "market_data_cache"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String(20), nullable=False)
    data_type = Column(String(50), nullable=False)  # price, technical, company_info
    
    # Data
    data = Column(JSON, nullable=False)
    
    # Cache metadata
    expires_at = Column(DateTime, nullable=False)
    api_source = Column(String(50))  # Which API provided this data
    cache_hits = Column(Integer, default=0)
    
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Indexes
    __table_args__ = (
        Index('idx_symbol_type', 'symbol', 'data_type', unique=True),
        Index('idx_expires_at', 'expires_at'),
    ) 